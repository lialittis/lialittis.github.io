<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>CS423 Distributed Information Systems | Tianchi YU</title> <meta name="author" content="Tianchi YU"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://lialittis.github.io/blog/2020/CS423-Distributed-Information-Systems/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Tianchi </span>YU</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">GitRepos</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">CS423 Distributed Information Systems</h1> <p class="post-meta">August 30, 2020• TC YU</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/tag/machine-learning"> <i class="fas fa-hashtag fa-sm"></i> machine learning</a>     ·   <a href="/blog/category/courses"> <i class="fas fa-tag fa-sm"></i> Courses</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> \[\def\abs#1{\left|\,#1\,\right|}\] <h1 id="cs423">CS423</h1> <blockquote> <p><a href="https://github.com/zifeo/EPFL/blob/master/LICENSE" rel="external nofollow noopener" target="_blank">GNU General Public License v3.0</a> licensed. Source available on <a href="https://github.com/zifeo/EPFL" rel="external nofollow noopener" target="_blank">github.com/zifeo/EPFL</a>.</p> </blockquote> <p>Spring 2017: Distributed Information Systems</p> <p>[TOC]</p> <h2 id="0-overview">0 Overview</h2> <h3 id="information-system">Information system</h3> <ul> <li>information system : software that manages a model of some aspect of real world within a distributed computer system for a given purpose</li> <li>real world aspect : physical phenomena, social organization, humman thought</li> <li>model : set of constants (identifiers), functions (relations), axioms (constraints) <ul> <li>representation of functions : algorithm (implicit), enumaration (explicit) = data</li> <li>interpretation function : homomorphic function (preserve form) from model constant to real-world objects, $I(f(·,\ldots,·))=f_{real}(I(·),\ldots,I(·))$</li> <li>computer system representation : data model that use data structure and operations</li> </ul> </li> <li>definitions : data model $D$, database $DB$, data definition language $DDL$, data manipulation language $DML$, schema $S$</li> <li>abstraction level <ul> <li>knowledge : schema that evolve dynamically, knowledge graph</li> <li>structured data : according to a schema, relational data, rdf, xml</li> <li>unstructured data : measurement data, text, video</li> </ul> </li> <li>data independence : same data interpreted in different ways <ul> <li>logical vs physical realization : use interface</li> <li>pragmatic layer : user/community specific (social utility management), evaluation</li> <li>semantic layer : domain specific (information system), interpretation</li> <li>syntactic layer : domain independent (database system), measurement</li> <li>physical layer : storage (operating system)</li> </ul> </li> </ul> <h3 id="data-management">Data management</h3> <ul> <li>data management tasks : e.g. row vs column store <ul> <li>efficient : storage, indexing, search, aggregation</li> <li>peristence</li> <li>consistency</li> </ul> </li> <li>optimizing access database : physical design (frequencies, predicates, before database access), declarative query optimization (logical, index exploitation, during database access)</li> <li>safe storage and update : concurrency, recovery</li> <li>transaction : isolation (not inter-user influence), atomaticity and durability (failures do not affect)</li> <li>modelling architecture : ANSI <ul> <li>conceptual schema : domain specifc, abstract models</li> <li>logical schema : data models</li> <li>physical schema : physical storage on disk, network</li> </ul> </li> <li>information system modelling <ul> <li>semantic layer : domain specific, information system with interpretation</li> <li>syntactic layer : domain independent, database system</li> <li>physical layer : operation system connecting to database</li> </ul> </li> </ul> <h3 id="information-management">Information management</h3> <ul> <li>information management tasks <ul> <li>retrieval : given a model, find specific data</li> <li>data mining : given data, find a model, higher level abstractions for lower level data</li> <li>conceptual modeling : analyze real world and specify model</li> <li>evaluation : given a model, evalute it against reality</li> <li>control, output : adapt system</li> <li>monitoring, input : collect data</li> </ul> </li> <li>utility of information : value depends on importance and quality of decision</li> </ul> <h3 id="distributed-information-systems">Distributed information systems</h3> <ul> <li>centralization vs distribution : locality, scalability, parallelism <ul> <li>heterogeneous information systems : different models, require interoperable IS</li> <li>autonomy : distribution of control</li> </ul> </li> <li>distributed data management <ul> <li>partitioning</li> <li>replication and caching</li> <li>data access : push, pull, indexing, query distribution</li> <li>communication model <ul> <li>unicast : point-to-point, request-reply</li> <li>multicast : propagate request to mulptile receivers (gossiping)</li> <li>broadcast : wireless channels</li> </ul> </li> <li>dissemination : periodic, conditional, ad-hoc</li> </ul> </li> <li>data overload : usefulnes, starvation when data supply less than data demand</li> <li>semantic heterogeneity : real world aspect modelled differently, relating different model require often humain, caused by automony <ul> <li>standardization : mapping though standards</li> <li>ontologies : mediated mapping, explicit specification of conceptualization of real world</li> <li>mapping : direct mapping, detect correspondance, resolve conflict, integrate schema</li> </ul> </li> <li>syntactic heterogeneity : same data represented using different data models (xml, graphs, rdf)</li> <li>evaluating : trust (reputation-based), quality of information (pagerank), privacy (obfuscation)</li> <li>distributed control : self organized, coordination in large-scale systems needs to be decentralized</li> <li>big data : volume, velocity, variety, veracity</li> </ul> <h2 id="1-information-retrieval">1 Information retrieval</h2> <p><img src="./assets/img/cs423-0.jpg" alt=""></p> <ul> <li>information retrieval : task of finding in large collection of documents those that satisfy user needs</li> <li>document constituents <ul> <li>social : people, authors, consumers, mentionned, social networks, communities, influence as relationship</li> <li>content : text, media, search, clustering, topics, classification as relationship</li> <li>concept : general ideas, explicit annotation, entities extracted, taxonomies or ontologies as relationship</li> </ul> </li> <li>retrieval model <ul> <li>determines : structure of document, query respresentation and similarity matching function</li> <li>relevance : no objective measure, reflect right topic, user need, authority, recency</li> <li>browser : retrieval ranked result interpreted by system, browsing as interpretation of information by human</li> </ul> </li> <li>evaluation : relevant document R, answer set A, using TREC dataset <ul> <li>unranked result set : all elements are equally important</li> <li>recall : $R=\frac{tp}{tp+fn}=P(retrieved\mid relevant)$</li> <li>precision : $P=\frac{tp}{tp+fp}=P(relevant\mid retrieved)$</li> <li>F-measure : weighted harmonic mean $F=\frac{1}{\alpha\frac{1}{P}+(1-\alpha)\frac{1}{R}}\in[0,1]$</li> <li>F1 : balanced F-measure with $\alpha=\frac{1}{2}$ give $F1=\frac{2PR}{P+R}$</li> <li>arithmetic mean : $\frac{tp+tn}{tp+tn+fp+fn}$, not suitable</li> <li>ranked retrieval : interpolated precision $P_{int}( R)=\max_{R’\ge R} R’$</li> <li> <table> <tbody> <tr> <td>mean average precision : $MAP(Q)=\frac{1}{</td> <td>Q</td> <td>}\sum_{j=1}^{</td> <td>Q</td> <td>}\frac{1}{m_j}\sum_{k=1}^{m_j}P(R_{jk})$ with $Q$ set of queries, with $R_{jk}$ top $k$ documents for query $q_j$</td> </tr> </tbody> </table> </li> <li>specificity : $S=\frac{tn}{fp+tn}=P(notRetrieved\mid notRelevant)$, steeper the better, ROC curve</li> </ul> </li> </ul> <h3 id="text-based-information-retrieval">Text-based information retrieval</h3> <p><img src="./assets/img/cs423-0.1.jpg" alt=""></p> <ul> <li>text-based information rertieval : <ul> <li>full-text : ignore grammar, meaning, keep only word, layout and metadata can be taken into account</li> <li>pre-processing : tokens, stopwords, stemming, manual indexing</li> <li>inverted file : indexing</li> </ul> </li> <li>basic concepts <ul> <li>document : $d$, express ideas</li> <li>query : $q$, information need</li> <li>index term $k$ : semantic unit (word, short phrase, root of a word)</li> <li>database : $DB$, collection of $n$ documents $d_j\in DB$</li> <li>vocabulary : $T$, collection of $m$ index terms $k_i\in T$</li> <li>index term importance : $d_j=(w_{1j},\ldots,w_{mj})$ with weights $w_{ij}\in[0,1]$</li> <li>similarity coefficient : $sim(q, d_j)$ estimate relevance of $d_j$ for query $q$</li> <li>term-document matrix : contains only terms that occur multiple times, no stop word), term (vertical) vs documents (horizontal)</li> </ul> </li> <li>boolean retrieval : which term should be present <ul> <li>similarity computation <ul> <li>determine disjunctive normal form : $q=ct_1\,OR\,\ldots\,OR\, ct_l$ with $ct=t_1\, AND\,\ldots\, AND\, t_k$ and $t_k\in{t, NOT\, t}$</li> <li>create weight vector $vec(ct)=(w_1,\ldots,w_m)$ for each conjunctive term <ul> <li>$w_i=1$ is $k_i$ occurs in $ct$</li> <li>$w_i=-1$ if not $k_i$ occurs in $ct$</li> <li>$0$ otherwise</li> </ul> </li> <li>if one weight vector of conjunctive term matches document : $d_j$ relevant ($sim(d_j,q)=1$), $vec(ct)$ matches $d_k$ if $w_i=1\wedge w_{ij}=1$ or $w_i=-1\wedge w_{ij}=0$</li> </ul> </li> </ul> </li> </ul> <h3 id="vector-space-retrieval">Vector space retrieval</h3> <ul> <li>vector space retrieval : allow ranking, tolerance with non-binary weights <ul> <li>similarity computation : $sim(q,d_j)=\cos\theta=\frac{d_j\cdot q}{\abs{d_j}\abs{q}}$ <ul> <li>$d_j=(w_{1j},\ldots,w_{mj})$ with $w_{ij}&gt;0$ if $k_i\in d_j$</li> <li>$q=(w_{1q},\ldots,w_{mq})$ with $w_{iq}\ge 0$</li> <li>$\abs{v}=\sqrt{\sum_{i=1}^m v_i^2}$</li> </ul> </li> <li>term frequency : $tf(i,j)=\frac{freq(i,j)}{\max_{k\in T} freq(k,j)}$ of term $k_i$ in $d_j$</li> <li>inverse document frequency : $idf(i)=\log\frac{n}{n_i}$ with $n_i$ number of document in which $k_i$ occurs</li> <li>query weight : $w_{ij}=tf(i,j)idf(i)$ <img src="./assets/img/cs423-1.jpg" alt=""> </li> </ul> </li> </ul> <h3 id="probabilistic-information-retrieval">Probabilistic information retrieval</h3> <ul> <li>probabilistic information retrieval : attempt to directly model relevance as probability <ul> <li>query likelihood model : $P(d\mid q)$ assume $P(d)$ uniform across collection, $P(q)$ same for all documents</li> <li>language modeling : assume each document generated by language model, probabilities for each ngrams</li> <li>query : $P(q\mid M_d)$</li> <li>MLE : $P_{mle}(t\mid M_d)=\frac{tf_{t,d}}{L_d}$ with $tf_{t,d}$ number of occurences of $t$ in $d$ (term frequency) and $L_d$ number of terms in document (document length)</li> <li>model : $P(q\mid M_d)=\Pi_{t\in Q}P_{mle}(t\mid M_d)$</li> <li>smoothed model : $P(t\mid d)=\lambda P_{mle}(t\mid M_d)+(1-\lambda)P_{mle}(t\mid M_c)$ with $M_c$ language model over whole collection, add small weight for non-occuring term $P(t\mid M_d)\le cf_t/T$ for $cf_t$ occurence of $t$ in collection and $T$ total number of terms in collection <ul> <li>model : $P(d\mid q)\propto P(d)\Pi_{t\in q}((1-\lambda)P(t\mid M_c)+\lambda P(t\mid M_d))$, tuning can be query-dependent</li> </ul> </li> </ul> </li> </ul> <h3 id="query-expansion">Query expansion</h3> <ul> <li>query expansion : increase recall by adding terms <ul> <li>local approach : user relevance feedback, use information from current query results <ul> <li>user identifies documet as (non)-relevant</li> <li>collection centroid : $\mu(D)=\frac{1}{\abs{D}}\sum_{d\in D}d$ of document set</li> <li>Rocchio algorithm : find query that optimally separates relevant from non-relevant, $q_{opt}=\arg\max_{q}[sim(q,\mu(D_r))-sim(q,\mu(D_n))]$</li> <li>identifying relevant document : $q_{opt}=\mu(D_r)+[\mu(D_r)-\mu(D_n)]$, but user feedback incomplete, user feedback can be homogeneous</li> <li>smart : practical relevance feedback, $q_{approx}=\alpha q+\frac{\beta}{\abs{D_r}}\sum_{d_j\in D_r}d_j-\frac{\gamma}{\abs{R\setminus D_r}}\sum_{d\not\in D_r}d_j$ with tuning parameters, result $R$ and relevant document $D_r$</li> <li>pseudo-relevance : if no user feedback, choose top-k and apply SMART, works good unless horribly failed (query drift)</li> </ul> </li> <li>global approach : query expansion, use information from a document collection, use query independent resource <ul> <li>automatic thesaurus generation : similary between two words, co-occur, gramatical relation</li> <li>query logs : exploit correlation, users extends query, users refer to same result</li> </ul> </li> </ul> </li> </ul> <h3 id="indexing-for-information-retrieval">Indexing for information retrieval</h3> <ul> <li>indexing for information retrieval <ul> <li>inverted files : word-oriented mechanism, semi-static collection, optimized for search <ul> <li>inverted list : $l_k=&lt;f_k:d_{i_1},\ldots,d_{i_{fk}}&gt;$ with $f_k$ number of document in which $k$ occurs, $d$s document identifiers of document containing $k$</li> <li>lexicographically ordered sequence : $IF=&lt;i,k_i,l_{k_i}&gt;$ <ul> <li>heap’s law : $0.4&lt;\beta&lt;0.6$ <img src="./assets/img/cs423-2.jpg" alt=""> <img src="./assets/img/cs423-3.jpg" alt=""> <img src="./assets/img/cs423-4.jpg" alt=""> </li> </ul> </li> </ul> </li> <li>searching <ul> <li>vocabulary search</li> <li>retrieval of occurences</li> <li>manipulation of occurences</li> </ul> </li> <li>construction <ul> <li>search phase : trie storing for each word a list of its occurences, sequentially</li> <li>storage phase : write list of occurences contiguously to disk, write sorted vocabulary, O(n)</li> <li>index : can be merged if not fit in memory $O(n\log_2(n/M))$ with memory $M$, map-reduce</li> </ul> </li> <li>granularity <ul> <li>coarser : text spanning multiple document</li> <li>finer : paragraph, sentence, words</li> <li>general rule : finer granularity the less post-processing but larger index</li> </ul> </li> <li>index compression : replace ordered document identifier in inverted list by their differences (10-15%)</li> </ul> </li> </ul> <h3 id="distributed-retrieval">Distributed retrieval</h3> <ul> <li>distributed retrieval : aggregate weights for all documents <ul> <li>Fagin’s algorithm : enrties in posting lists sorted according to tf-idf weights, scan in parallel all list in round-robin till $k$ documents detected in all list, lookup missing weights for documents not seen in all lists, select top-$k$ elements, $O((k n)^{1/2})$ (assuming non correlated)</li> </ul> </li> </ul> <h3 id="linked-based-ranking">Linked-based ranking</h3> <ul> <li>linked based retrieval <ul> <li>hypertext : anchor text as context, hyperlink as quality signal</li> <li>anchor text : surrounding a hyperlink</li> <li>scoring : weight depdending on the authority of the anchor page</li> <li>nepotistic : promoting your own family members, can give lower weights to links within same site</li> </ul> </li> <li>pagerank <ul> <li>citation analysis <ul> <li>frequency : importance</li> <li>co-citation : related</li> <li>indexing : who is this author cited by</li> <li>authority of sources : impact factor of journals</li> </ul> </li> <li>relevance <ul> <li>number of referrals (incoming links)</li> <li>number of high relevance refferals</li> </ul> </li> <li>scoring <ul> <li>link-based : random equiprobable walk, long-term visit rate is score</li> <li>teleporting : random web page at dead end, probability to jump at each visit</li> <li>model : $P(p_i)=\sum_{p_j\mid p_j\to p_i}\frac{P(p_j)}{C(p_j)}$ for $N$ pages with outgoing links $C(p)$ and probability to visit $P(p_i)$</li> <li> <table> <tbody> <tr> <td>matrix equation : $R_{ij}=\frac{1}{C(p_j)}$ if $p_j\to p_i$ else $0$, $p=(P(p_1),\ldots,P(p_n))$, $p=Rp$ for $</td> <td> </td> <td>p</td> <td> </td> <td>_1=\sum p_i=1$, relevance is highest eigenvalue</td> </tr> </tbody> </table> </li> </ul> </li> <li>pagerank : $P(p_i)=c(\frac{1-q}{N}+q\sum_{p_j\mid p_j\to p_i}\frac{P(p_j)}{C(p_j)})$ for $c\le 1$, $p=c((qR+(1-q)E))p=c(qRp+\frac{(1-q)}{N} e)$ with $E=1/N$ square matrix and $E\cdot p=e$ <img src="./assets/img/cs423-5.jpg" alt=""> </li> </ul> </li> <li>HITS : hyperlink-induced topic search <ul> <li>idea : for a query, find two sets of inter-related pages instead of lists of page <ul> <li>hub page : good lists of links for subject</li> <li>authorative : pages occuring recurrently on good hubs</li> </ul> </li> <li>best : broad topic, post processing</li> <li>computing : 5 iterations to converge in practice <ul> <li>select $N$ pages containing relevant hubs and authorities</li> <li>for each page $p$ compute hub score $H(p_i)=\sum_{p_i\to p_j} A(p_j)$ and authority score $A(p_i)=\sum_{p_j\to p_i} H(p_j)$, normalize sum of square = $1$</li> <li>initialize $h(p)=1/N^2$ and $a(p)=1/N^2$, iteratively update and return high scores</li> </ul> </li> <li>eigenvalue : $y=Lx$ and $x=L^\top y$ give $y^<em>$ eigenvector of $LL^\top$ and $x^</em>$ eigenvector of $L^\top L$, always converge (power iteration) to highest one</li> <li>root set : all pages mentioning the query</li> <li>base set : page that points to root set or is pointed by root set</li> <li>issues : structural anomalies of link structures, tropic drift, mutually reinforcing affiliates</li> </ul> </li> <li>social network analysis : pagerank and hits</li> <li>link indexing <ul> <li>connectivity server : stores mapping in memory from URL to outlinks, URL to inlinks</li> <li>adjaceny lists : set of neighbors of a node, each number represented by an URL, 320 GB for actual web (10 pages per links), but locality (gap encoding, gamma encoding) and similarity is good (copy data from similar lists, reference list, copy lists)</li> </ul> </li> </ul> <h2 id="2-data-mining">2 Data mining</h2> <ul> <li>big data challenge <ul> <li>data : accessible, legal, format</li> <li>questions : searching for insights</li> <li>algorithms : smart and efficient</li> <li>systems : handling such load</li> </ul> </li> <li>local properties <ul> <li>patterns : pattern mining, association rules</li> </ul> </li> <li>global models <ul> <li>descriptive structure of data : clustering, information retrieval</li> <li>predictive function of data : classification, regression</li> <li>exploratory data analysis : interactive tools, visualisation</li> </ul> </li> <li>data mining algorithm <ul> <li>pattern structure/model representation</li> <li>scoring function</li> <li>optimisation and search : tune parameters</li> <li>data management : very large dataset</li> </ul> <h3 id="association-rule-mining">Association rule mining</h3> </li> <li>association rule <ul> <li>form $body\to head\,[support, confidence]$ with $body$ and $head$ being $predicate(x,x\in{items})$</li> <li>multimensional : $body_1\wedge body_2$, can be decomposed to multi single rules</li> <li>support : probability that body and head occur in transaction $p({body, head})$</li> <li>confidence : probability that if body occurs, also head occurs $p({head}\mid{body })$</li> <li>definition <ul> <li>itemset : subset of all items $I$</li> <li>transaction : $(tid, T)$ with $T\subset I$</li> <li>database : $D$ set of all transcactions</li> <li>association rule : $A\to B\,[s,c]$ <ul> <li>$A,B\subseteq I$</li> <li>$A\cap B$ empty</li> <li> <table> <tbody> <tr> <td>$s=p(A\cup B)=count(A\cup B)/</td> <td>D</td> <td>$</td> </tr> </tbody> </table> </li> <li>$c=p(B\mid A)=s(A\cup B)/s(A)$</li> </ul> </li> </ul> </li> <li>problem : find all rules s.t. $s&gt;s_{min}$ (high support) and $c&gt;c_{min}$ (high confidence)</li> <li>two step approach <ul> <li>find frequent itemsets : $J\subseteq I$ s.t. $p(J)&gt;s_\min$, if $A\cup B$, then only $A\to B$ can be an associate rule, any subset of frequent itemset is also frequent (apriori property), find frequent itemsets with increasing cardinality from $1$ to $k$ to reduce search space</li> <li>select pertinent rules : $A\to B$ s.t. $A\cup B=J$ and $P(B\mid A)&gt; c_\min$</li> <li>apriori property : any subset of frequent itemset is also frequent itemset <ul> <li>union of two $k-1$ that differs only by one item is candidate</li> <li>join algorithm : sort itemset in $L_{k-1}$, find all pairs with same first $k-2$ items, but different $k-1$th item, join two itemset,</li> <li>prune : not frequent ones (or not existing) <img src="./assets/img/cs423-5.1.jpg" alt=""> <img src="./assets/img/cs423-5.2.jpg" alt=""> <img src="./assets/img/cs423-6.jpg" alt=""> <img src="./assets/img/cs423-7.jpg" alt=""> </li> </ul> </li> </ul> </li> <li>alternative measures of interest : interesting rule those with high positive or negative interest values <ul> <li>added value : $AV(A\to B)=confidence(A\to B)-support(B)$</li> <li>lift : $lift(A\to B)=\frac{confidence(A\to B)}{support(B)}$</li> </ul> </li> <li>quantitative attributes : transforming quantitative (numeric ordered values) into categorical ones, rules depends on discretisation <ul> <li>static discretisation : predefined bins</li> <li>dynamic discretisation : based on data distributions</li> </ul> </li> <li>apriori for large dataset <ul> <li>transaction reduction : omit non frequent one in subsequent scans</li> <li>sampling : randomly sample with probability $p$, detect frequent itemset with support $ps$, eliminate false positive by counting frequent items on complete data (if sorted, take first ones), false negative can be reduced by choosing lower threshold $0.9ps$</li> <li>partitioning : SON algorithm <ul> <li>divide in $1/p$ partitions, repeatedly read partition into main memory</li> <li>detect in-memory algorithm to find all frequent itemsets with support threshold $ps$</li> <li>itemset becomes candidate if found to be frequent in at least one partition</li> <li>second pass count candidate items and determine which are frequent in entire set</li> <li>monotonicity idea : itemset cannot be frequent in full set without being frequent in at least one partition</li> </ul> </li> </ul> </li> <li>FP growth : frequent itemset discovery without candidate generation <ul> <li>build FP-tree datastructure <ul> <li>compute support for each item : sort items in order of decreasing support (compact tree)</li> <li>construct FP : expand one itemset at a time</li> <li>introduce links between similar labels</li> </ul> </li> <li>extract frequent itemsets directly from FP-tree <ul> <li>bottom-up approach : for each item extract tree with paths ending in the item, start with lowest support</li> <li>conditional : FP-tree that contains selected items, remove nodes of the item, remove nodes with unsufficient support count <img src="./assets/img/cs423-7.1.jpg" alt=""> <img src="./assets/img/cs423-7.2.jpg" alt=""> </li> </ul> </li> <li>advantages : only 2 passes, compresses dataset, much faster than apriori</li> <li>disadvantages : less efficient with high support threshold, in-memory, difficult to distribute</li> </ul> </li> </ul> </li> </ul> <h3 id="information-retrieval-advanced-models-for-test-representation">Information retrieval advanced models for test representation</h3> <ul> <li>vector spacew retrieval : bad handling of synonym (car and automobile, poor recall) and homony (apple, poor precision)</li> <li>dimensionality reduction : map documents and queries into lower-dimensional space composed of higher-level concepts</li> <li>concept space : normalized concept vector</li> <li>term-document matrix : $M_{ij}$ with $m$ rows (terms) and $n$ columns normalized (documents) given a weight $w_{ij}$ associated with $t_i$ and $d_j$ (can be based on tf-idf weighting scheme) <ul> <li>computing ranking : $M^\top\cdot q$</li> </ul> </li> <li>singular value decomposition : $M=KSD^\top$ with $KK^\top=I=DD^\top$ having orthonormal columns and $S=r\times r$ diagonal matrix of singular values in descreasing order ($r=\min(m,n)$) <ul> <li>$K=eigen(MM^\top)$</li> <li>$D=eigen(M^\top M)$</li> <li>complexity : $O(n^3)$ if $m\leq n$</li> <li> <table> <tbody> <tr> <td>$s_i$ : length of semi-axes of hyperellipsoid $E={Mx \mid</td> <td> </td> <td>x</td> <td> </td> <td>_2=1}$</td> </tr> </tbody> </table> </li> </ul> </li> <li>latent semantic indexing : selection only the largest $s$ from SVD giving $M_s=K_sS_SD_s^\top$, poor statisical explanation <img src="./assets/img/cs423-7.3.jpg" alt=""> </li> <li>cosine similarity : compare columns $(D_s^\top)_i$ and $(D_s^\top)_j$, query $q$ applies same transformation (treated as additional document vector) <ul> <li>mapping $M$ to $D$ : $M=KSD^\top$ as $D=M^\top KS^{-1}$ giving $q^*=q^tK_sS_s^{-1}$</li> <li> <table> <tbody> <tr> <td>similarity : $sim(q^<em>,d_i)=\frac{q^</em>\cdot (D_s^\top)_i}{</td> <td>q^*</td> <td> </td> <td>(D_s^\top)_i</td> <td>}$</td> </tr> </tbody> </table> </li> </ul> </li> <li>probabilistic latent semantic analysis : based on Bayesian Networks</li> <li>latent dirichlet allocation : based on Dirichlet distribution, state-of-the-art, interpretable <ul> <li>idea : assume document collection randomly generated from known set of topics (generative model, for each doc, choose mixture of topics, sample a topic, sample a word), given document collection, reconstruct topic model</li> </ul> </li> <li>word embeddings : neighborhood of word $w$ express a lot about its meaning, model how likely a word and a context occur together <ul> <li>similarity based representation : most successful idea, two words similar when they have similar contexts (syntactic, semantic)</li> <li>context : $C(w)$ giving word context occurence $(w,c),c\in C(w)$</li> <li>model : two matrices $W^{(1)}$ and $W^{(2)}$ to map words and context words <img src="./assets/img/cs423-8.jpg" alt=""> </li> <li>probability : $p(D=1\mid w,c;\theta)=\frac{1}{1+e^{- v_c\cdot v_w}}=\sigma(v_c\cdot v_w)$, whether conext comes from data</li> <li>goal : find $\theta$ s.t. overall probability is maximized $\theta=\arg\max_{\theta}\Pi_{(w,c)\in D}P(D=1\mid w,c,\theta)\Pi_{(w,c)\in\tilde D}P(D=0\mid w,c,\theta)$ (require negative sample $\tilde D$)</li> <li>SGD : $\theta’=\theta + \alpha\Delta_\theta J_t(\theta)$ with $J(\theta)=-\log(\sigma(v_c\dot v_w))-\sum_{k=1}^K\log(\sigma(v_{c_k}\cdot v_w))$ only over row containing word</li> <li>negative sample : obtained from $P_n(w)=V\setminus C(w)$, empirical approach approximate probability by sampling few non-context words or choose probability $p_w^{3/4}$ instead of $p_w$</li> <li>low-dimensional representation : $W=w^{(1)}+W^{(2)}$</li> </ul> </li> <li>CBOW : continuious bag of words models, predict words from context</li> <li>GLOVE : exploits ratio of probabilities to capture semantic relationships among terms</li> </ul> <h3 id="clustering">Clustering</h3> <ul> <li>clustering : assign objects described by attributes to a class</li> <li>model : partition a set of objects into clusters, unsupervised</li> <li>similarity <ul> <li>intra-cluster : high</li> <li>inter-cluster : low</li> </ul> </li> <li>heuristic algorithms : $n$ objects, $k$ clusters, $t$ iteration <ul> <li>K-means : clustered by point whose mean distance minimal, $O(tkn)$, local optimum</li> <li>K-medoids : clustered by object whose mean distance minimal</li> <li>K-medians : clustered by point whose median distance minimal</li> </ul> </li> <li>partioning : given database $D$ of $n$ object, split $D$ into $k$ sets $C_1,\ldots,C_k$ s.t. $C_i\cap C_j=\emptyset$</li> <li> <table> <tbody> <tr> <td>score function : minimize $J=\frac{1}{n}\sum_{i=1}^k\sum_{x_j\in C_i}</td> <td> </td> <td>x_j-\mu_i</td> <td> </td> <td>^2$, $\mu_i=\frac{1}{</td> <td>C_i</td> <td>}\sum_{x_j\in C_i} x_j$</td> </tr> </tbody> </table> </li> <li>categorical attributes : use matching coefficient, distance = #pair-wise mismatches / #features</li> <li>distance function : $d(x,y)\ge 0$, $d(x,y)=0\iff x=y$, $d(x,y)=d(y,x)$, $d(x,z)\le d(x,y)+d(y,z)$</li> <li>density-based clustering : handle noise, cluster in one scan, discover non convex, no need to define cluster number <ul> <li>distance metric : $\epsilon$-neighborhood $N_\epsilon(q)={p\mid d(p,q)&lt;\epsilon }$</li> <li> <table> <tbody> <tr> <td>core point : if $</td> <td>N_\epsilon(q)</td> <td>\ge\mu$</td> </tr> </tbody> </table> </li> <li>directly density-reachable : $p$ from $q$ if $p\in N_\epsilon(q)$ and $|N_\epsilon(q)|\ge\mu$ (not core point but reachable is called border point, otherwise outlier) <img src="./assets/img/cs423-8.1.jpg" alt=""> </li> <li>directed graph : induced</li> <li>density-reachable : $p$ from $q$ if there is chain $p_1,\ldots,p_n$ $p_1=q$ $p_n=p$ s.t. $p_{i+1}$ directly density-reachable from $p_i$ <img src="./assets/img/cs423-8.2.jpg" alt=""> </li> <li>density connected : $p$ to $q$ if there is point $r$ s.t. both $p$ and $q$ density-reachable from $r$, symmetric <img src="./assets/img/cs423-8.3.jpg" alt=""> </li> <li>cluster : set of clusters unique, not necessary disjoint, $C$ satisfies <ul> <li>maximality : if $q$ in $C$ is core point, $p$ also in $C$ if density reachable</li> <li>connectivity : any two points in $C$ must be density connected</li> </ul> </li> <li>DBSCAN <ul> <li>initialization : $V_{core}$ set of core points, $P$ all points, set of clusters $C={}$, $O(n^2)$</li> <li>construction : while $V_{core}$ not empty, $O(n^2)$ <ul> <li>select point $p$ from $V_{core}$ and construct $S(p)$ set of all points density reachable from $p$ (breadth first search on $G$ starting from $p$)</li> <li>$C=C\cup{S(p)}$</li> <li>$P=P\setminus S(p)$</li> <li>$V_{core}=V_{core}\setminus S_{core}(p)$ where $S_{core}(p)$ core points in $S(p)$</li> <li>remaining points : unclustered</li> </ul> </li> </ul> </li> </ul> </li> <li>online incremental clustering</li> </ul> <h3 id="mining-social-graphs">Mining social graphs</h3> <ul> <li>graph : explicit relationships</li> <li>graph cluster : communities, interests, level of trust</li> <li>clique : complete subgraph</li> <li>linked <ul> <li>heavy intra-linked : high intra-cluster similarity</li> <li>scarcely inter-linked : low inter-cluster similarity</li> </ul> </li> <li>hierarchical clustering : iteratively identifies groups of nodes with high similarity <ul> <li>agglomerative algorithm : merge node and communities with high similarity</li> <li>divisive algorithms : split communities by removing links that connect nodes with low similarity</li> </ul> </li> <li>Louvain algorithm : agglomerative <ul> <li>modularity : measure for community quality, higher the better $\sum_{c\;in\; communities}(#edge\;within\;c - expected\;#edges\;within\;c)$ <ul> <li>expected number of edge : unweighted, uniform random graph (null model), total number of edge $m$, $k_i$ degree (outgoing edges of node $i$, $2m$ edge ends), node $j$ has an end with $k_j/2m$</li> <li>measure : $Q=\frac{1}{2m}\sum_{i,j}(A_{i,j}-\frac{k_ik_j}{2m})\delta(c_i,c_j)$ with $A_{ij}$ number of edges between $i$ and $j$, $c_i$ communities of node $i$, $Q\in[-1,1]$, significant $0.3-0.7$</li> </ul> </li> <li>first : find small communities by optimizing modularity locally (maximally) on all nodes, try all possibilities and choose the best</li> <li>then : each small community into a new community, repeat <img src="./assets/img/cs423-8.4.jpg" alt=""> </li> <li>communities : sets of nodes with many mutul connection, much less connections to the outside</li> <li>optimum : modularity determine best level to cutoff hierarchical</li> <li>complexity : $O(n\log n)$</li> </ul> </li> <li>Girvan-newman algorithm : divisive, decomposition by splitting edges with highest separation capacity <img src="./assets/img/cs423-8.5.jpg" alt=""> <ul> <li>betweenness measure : how well they separate communities, number of shortest paths passing over the edge <ul> <li>BFS : top down, for each node BFS, $#shortest paths(A-X)=\sum_{P\; parent\;of\; X}# shortest paths(A-P)$</li> <li>edge flow : edge flow, $weighttosplit(X)=1+\sum_{c\; child\; of\; X}# edgeweight(X-C)$</li> <li>BFS for each node, determine edge flow for each edge, sum up flow values (divide by 2 edge values as computed in both direction) <img src="./assets/img/cs423-8.6.jpg" alt=""> <img src="./assets/img/cs423-8.7.jpg" alt=""> </li> </ul> </li> <li>random walk betweenness : pair $n$ and $m$ chosen at random, walker stats at $m$ follow each adjacent link uniformly until $n$, betweenness is probability of crossing $i\to j$ after all possible choices for starting nodes $m$ and $n$</li> <li>until no edges left : remove edges with highest betweenness</li> <li>complexity : one link $O(n^2)$, all links $O(L n^2)$, sparse matrix $O(n^3)$</li> </ul> </li> </ul> <h3 id="classification">Classification</h3> <ul> <li>descriptive modeling : clustering</li> <li>predictive modeling : bayes, k-nearest, random forest, svm, boosted trees, etc.</li> <li>classification : supervised <ul> <li>input : set of objects (database $D$) with categorical/numerical attributes and one class label $C$</li> <li>model : $X^d\to C$</li> <li>output : returns class given the attribut</li> <li>learnt : training set</li> <li>evaluated : test set</li> <li>prediction : unknown labels</li> </ul> </li> <li>characteristics <ul> <li>predictive accuracy</li> <li>speed and scalability : time to build, use the model, in memory, disk</li> <li>robustness : handling noise, outliers, missing value</li> <li>interpretability : understand the model, compactness of the model</li> </ul> </li> <li>decision tree induction : flow chart lie tree <ul> <li>score function : accuracy</li> <li>optimisation : top-down tree construction + pruning</li> <li>construction : examples paritioned recursively based on selected most discriminative attributes</li> <li>stop partitioning : if all samples belong to same class (leaf), no attributes left (majority voting to assign class), no samples left</li> <li>attribute selection entropy : $H(P,N)=-\frac{P}{P+N}\log_2\frac{P}{P+N}-\frac{N}{P+N}\log_2\frac{N}{P+N}$</li> <li>attribute entropy : for attribute $A$ partitioning into $S_1,\ldots, S_v$, $H(A)=\sum_{i=1}^v\frac{P_i+N_i}{P+N}H(P_i,N_i)$, select lowest</li> <li>information gain : $Gain(A)=H(P,N)-H(A)$, select highest</li> <li>pruning : reduce overfitting by stop partitioning when large majority is positive <ul> <li>build full tree and replace nodes with leaves labelled with majority class if classification accuracy does not change</li> <li>minimum description length principle : best model $M_i$ minimize $L(M)+L(D\mid M)$ where $L(M)$ is lenght in bits of the description of the model (#nodes,#leaves,#arcs) and $L(D\mid M)$ is length in bits of description of encoded data with the model (#misclassifications)</li> </ul> </li> <li>extracting classification : if-then rules</li> <li>continous attributes : use binary decision trees <ul> <li>sort data according to attribute value</li> <li>determine value that maximizes the information gain by scanning though the data items</li> <li>scalability : persorting data and maintaining order, for everyt attribute separate and presorted table kept (use hashtable to maintain partition attribution) <ul> <li>selected attribute : partition table into two subtables</li> <li>other attributes : use temporary hash table to associate eac dataitem to its partition, then scanned and partitionned</li> </ul> </li> </ul> </li> <li>characteristics : automatic feature selection, minimal data preparation, non-linear model, easy to interpret, senstive to perturbation, overfit</li> </ul> </li> <li>ensemble methods : collection of simple/weak learner, combine results to make strong learner <ul> <li>bagging : train learner parallel on different samples, combine by voting or averaging</li> <li>stacking : combine models using a second stage learner like regression</li> <li>boosting : train learner on filtered output of other learners</li> </ul> </li> <li>random forest : learn $K$ different decision trees from independent samples, vote between different learners so model not too similar <ul> <li>aggregate output : majority vote</li> <li>sampling strategies : subset of different data, subset of attributes</li> <li>algorithm : typical parameters $m\approx\sqrt(p)$, $K\approx 500$ for $p$ total attributes <ul> <li>draw $K$ bootstrap samples of size $N$ from original dataset with replacement (bootstrapping)</li> <li>contruct decision tree and select a random set of $m$ attributes out of $p$ to infer split (feature bagging)</li> </ul> </li> <li>characteristics : complex decision without overfitting, popular for dense data (thousand of features), easy to implement, good for map reduce, worse than deep neural net, need many pass, hard to balance</li> </ul> </li> </ul> <h3 id="classification-methodology">Classification methodology</h3> <ul> <li>credibility : trustworthiness (well-intentioned, truthful, unbiased) + expertise (knownledge, experienced, competent)</li> <li>data collection and preparation <ul> <li>feature identitifcation : domain knownledge is needed <ul> <li>numerical : maybe discretisation</li> <li>ordinal</li> <li>categorical</li> </ul> </li> <li>labelling : time consuming, expensive, ask expert, ask crowd, complementary source of information (distant learning) <ul> <li>crowd-workers <ul> <li>truthful : expert, normal</li> <li>untruthful : sloppy (limited knownledge, misunderstanging), uniform spammer, random spammer</li> </ul> </li> <li>non-iterative aggregation algorithms : process answers matrix and produce estimate of most likely answer to be correct</li> <li>majority decision : MD, no preprocessing, $P(x_j=l)=\frac{1}{N}\sum_i^N(1\mid a_i(x_j)=l)$ with $x_j$ object to label $l$,</li> <li>honey pot : HP, insert known labels, remove workers that fail at correctly labelling more that $m$%, then majority decision</li> <li>iterative aggregation algorithms : estimate worker expertise from answers</li> <li>expectation maximisation : EM <ul> <li>e-step : estimate label from answers of workers, $P(x_j=l)=\frac{1}{\sum_{i=1}^N w_i}\sum_{i=1}^N (w_i\mid a_i(x_j)=l)$</li> <li>m-step : estimate reliability of workers from consistency of answers, expertise $w_i=\frac{1}{M}\sum_{j=1}^M(1\mid a_i(x_j)=\arg\max P_l(x_j=l))$</li> </ul> </li> </ul> </li> <li>discretization <ul> <li>unsupervised discretisation : equal with, equal frequency, clustering</li> <li>supervised discretisation : independence test $x^2$ statistics, $x^2=\sum_i\sum_j \frac{(O_{ij} - E_{ij})^2}{E_{ij}}$ with $O_{ij}$ observed frequency and $E_{ij}$ expected frequency, independent if $P(x^2\mid DF=1)&gt;0.05$ with $DF$ degree of freedom ($=(#row - 1)(#cols -1)$), merge interval</li> </ul> </li> <li>feature selection : ${N\choose M}$ subsets, select $M$ optimal features, correlation is not causality, collective relevant features may look individually irrelevant <ul> <li>filtering : consider feature as independent, rank them according to predictive power ($P(x^2\mid DF=n-1)$ give rank measure) <ul> <li>mutual information : numerical $I(F;C)=H( C)-H(C\mid F)=H(F)+H( C)-H(F,C)$</li> </ul> </li> <li>wrapper : consider dependencies among features, create classifier at each iteration and evaluate its performance, stop if no improvement</li> </ul> </li> <li>feature normalization : classifier are sensitive to scale <ul> <li>standardization : $x_i’=\frac{x_i-\mu_i}{\sigma_i}$ normal distribution</li> <li>scaling : $x_i’=\frac{x_i-m_i}{M_i-m_i}$ map to interval $[0,1]$, bad with outliers</li> </ul> </li> </ul> </li> <li>model training, selection and assessment <ul> <li>selecting performance metrics <img src="./assets/img/cs423-8.8.jpg" alt=""> <ul> <li>accuracy : $A=\frac{TP+TN}{TP+TN+FP+FN}=\frac{TP+TN}{N}$, when classes not skewed, error same importance</li> <li>precision : $P=\frac{TP}{TP+FP}$</li> <li>recall : $R=\frac{TP}{TP+FN}$</li> <li>F-score (F1) : $F1=2\frac{PR}{P+R}$</li> <li>F-beta score : $F_\beta=\frac{(1+\beta^2)PR}{\beta^2P+R}$</li> </ul> </li> <li>model selection : tune parameters (regularisation factor, threshold, distance function, number of neighbours) <ul> <li>train, test (model assessment), validation (model selection)</li> <li>loss function <ul> <li>categorical output : $J=\sum_{i=1}^n #(y\not = f(x_i))$</li> <li>real value output : $J=\frac{1}{n}\sum_{i=1}^n(y_i-f(x_i))^2$, absolute</li> </ul> </li> </ul> </li> <li>organizing training and test data <ul> <li>k-fold cross validation : $K-1$ training set, $1$ validation, avergage of $K$</li> <li>leave one out cross validation : at extreme k-fold, $N-1$ training set, $1$ validation, avergage of $N$</li> <li>fight skew <ul> <li>stratification : validation set as random sample but ensure approximately proportionally represented</li> <li>over and under sampling : including over proportionally number from smaller class (over-sampling) and under proportional number from larger class (under-sampling)</li> </ul> </li> <li> <table> <tbody> <tr> <td>good model : good estimate $f:X^d\to Y$ with error $err(f_d,T)=\frac{1}{</td> <td>T</td> <td>}\sum_{X\in T}(f_D(X)-y)^2$ with $T$ validation set</td> </tr> </tbody> </table> </li> <li>expected error : $EErr_{train}=E_D[Err(f_D,D)]$</li> <li>test error : $EErr_{test}=E_{D,T}[Err(f_D,T(D))]=bias^2+variance$ <ul> <li>bias : $bias=E_{D,T}[f_D(X)-y]$, high is a sign of under-fitting (simple model)</li> <li>variance : $variance =E_{D,T}[(f_D(X)-E_D[f_D(X)]^2]$, high is a sign of over-fitting (complex model)</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h3 id="document-classification">Document classification</h3> <ul> <li>document classification : unstructured documents, spam filtering, sentiment analysis, document filtering, features <ul> <li>words of documents : bag of words, document vector</li> <li>detailed information on words : phrases, word fragments, grammatical features</li> <li>metadata about document and its author</li> <li>challenge : very high dimension, need feature selection (mutual information), dimensionality reduction (word embedding), scalable algorithms</li> </ul> </li> <li>k-Nearest-Neighbors : vector space model <ul> <li>retrieve k nearest neighbors</li> <li>choose majority class label : estimate $P(C\mid D)\approx #C/k$ probablity document has indeed class $C$</li> <li>small $k$ : (simple model), low bias, high variance</li> </ul> </li> <li>naive Bayes classifier : probablistic retrieval, bag of words <ul> <li> <table> <tbody> <tr> <td>how characteristic $w$ for $C$ : $P(w\mid C)=\frac{</td> <td>w\in D,D\in C</td> <td>+1}{\sum_{w’}</td> <td>w’\in D,D\in C</td> <td>+ 1}$</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td>how frequent $C$ : $P( C)=\frac{</td> <td>D\in C</td> <td>}{</td> <td>D</td> <td>}$</td> </tr> </tbody> </table> </li> <li> <table> <tbody> <tr> <td>Bayes law : $P(C\mid D)\propto P( C)\Pi_{w\in D}P(w</td> <td>C)$</td> </tr> </tbody> </table> </li> <li>most probable class : $C_{NB}=\arg\max_C(\log P(C )+\sum_{w\in D}\log P(w\mid C))$</li> </ul> </li> <li>word embeddings : <ul> <li>probability $w$ occurs with context word $c$ : $P(D=1\mid w,c;\theta)$</li> <li>consider instead of (word, context) : (class, paragraph)</li> <li>learn : $P(C\mid p)=\frac{e^{v_p\cdot v_c}}{\sum_{C’}e^{-v_p\cdot v_{C’}}}$</li> <li>Fasttext: classifier based on word embedding, n-grams (phrases), subword information (character n-grams)</li> </ul> </li> </ul> <h3 id="recommender-systems">Recommender systems</h3> <ul> <li>model : users, items ranks items in order of descreased relevance</li> <li>collaborative-based : tell me what other people like <ul> <li>wisdom of the crowd : users give ratings to items, user with similar tastes in the past will have similar tastes in the future</li> <li>users based : estimate rating $r_U(I)$ : find set of users $N_U$ who liked the same items as $U$ and rated $I$, aggregate ratings of $I$ provided by $N_U$, cold start, not scalable, mean rating $r_x$ of user $x$ <ul> <li>Pearson correlation coefficient : $sim(x,y)=\frac{\sum_{i=1}^N(r_x(i)-\bar r_x)(r_y(i)-\bar r_y)}{\sqrt{\sum_{i=1}^N(r_x(i)-\bar r_x)^2}\sqrt{\sum_{i=1}^N(r_y(i)-\bar r_y)^2}}$ between $-1$ and $1$</li> <li>cosine similarity : $sim(x,y)=\cos(\vartheta)=\frac{\sum_{i=1}^N r_x(i)r_y(i)}{\sqrt{\sum_{i=1}^N r_x(i)^2}\sqrt{\sum_{i=1}^N r_y(i)^2}}$</li> <li> <table> <tbody> <tr> <td>common aggregation : $r_x(a)=\bar r_x+\frac{\sum_{y\in N_U(x)} sim(x,y)(r_y(a)-\bar r_y)}{\sum_{y\in N_U(x)}</td> <td>sim(x,y)</td> <td>}$</td> </tr> </tbody> </table> </li> </ul> </li> <li>item-based : replace users by items $N_I(a)$, more stable, can be computed in advance, runtime neighboorhood small $N_I(a)$, item $b$ rated by $x$ <ul> <li> <table> <tbody> <tr> <td>common aggregation : $r_x(a)=\frac{\sum_{b\in N_I(a)}sum(a,b)r_x(b)}{\sum_{b\in N_I(a)}</td> <td>sim(a,b)</td> <td>}$</td> </tr> </tbody> </table> </li> </ul> </li> </ul> </li> <li>content-based : show me more of what I liked <ul> <li>find items similar to past items, aggregate ratings of most similar, cold start, recommend more of the same</li> <li>TF-IDF description weight : $w(t,a)=tf(t,a)idf(t)=\frac{freq(t,a)}{\max_{s\in T} freq(s,a)}\log\frac{N}{n(t)}$ with $n(t)$ number of items where term $t$ appears, after pre-processing (stopmwords, stemming, top M terms) <ul> <li>cosine similarity : $sim(a,b)=\cos(\vartheta)=\frac{\sum_{t=1}^T w(t,a)w(t,b)}{\sqrt{\sum_{t=1}^T w(t,a)^2}\sqrt{\sum_{t=1}^T w(t,b)^2}}$ with items $a$, $b$, term $t$</li> <li> <table> <tbody> <tr> <td>aggregation : $r_x(a)=\frac{\sum_{b\in N_I(a)} sim(a,b)r_x(b)}{\sum_{b\in N_I(a)}</td> <td>sim(a,b)</td> <td>}$</td> </tr> </tbody> </table> </li> </ul> </li> </ul> </li> <li> <table> <tbody> <tr> <td>matrix factorization : $\min_{q,p}\sum_{(u,i)\in M}(r_u(i)-q_i^\top p_u)^2+\lambda(</td> <td> </td> <td>q_i</td> <td> </td> <td>^2+</td> <td> </td> <td>p_u</td> <td> </td> <td>^2)$, incomplete matrix, SGD</td> </tr> </tbody> </table> </li> </ul> <h2 id="3-knowledge-modeling">3 Knowledge modeling</h2> <ul> <li>implicit knowledge : information retrieval, data mining</li> <li>explicit knowledge : knowledge modelling</li> </ul> <h3 id="semi-structured-data">Semi-structured data</h3> <ul> <li>schemas : datastructure for databases, relationa, xml, agreement on data structures, consistency, integrity, optimize query</li> <li>HTML : too limited, no schema, no constraints, hard to analyze</li> <li>semi-structured data : contains tags, markup to specify semantics, and relate values (e.g. hierarchically), embeds schema into data, email, json, xml <ul> <li>application-specific markup : making meaning of data explicit (through tags), XML extensible markup language</li> <li>serialization : canonical encoding into a text</li> <li>schema-less data : flexible, self-contained, but consistency and optimization not feasible <img src="./assets/img/cs423-8.9.jpg" alt=""> </li> </ul> </li> <li>document mode : serialized representation</li> </ul> <h3 id="semantic-web">Semantic web</h3> <ul> <li>semantic web : extension of current web in which information is given well-defined meaning <ul> <li>overcome semantic heterogeneity <ul> <li>standardization (integrated approach) : common user-defined, power play enforces it, integrated approach (exists common format, detailled, aggred upon by all parties)</li> <li>translation (federated approach) : mappings, require human, difficult, federated approach (no common format, accommodate on the fly, no party imposes models, languages and method of work)</li> <li>annotation (unified approach) : create relationships to agreed upon conceptualizations, meta-model, IS-A, unified approach (common format but only meta-level)</li> </ul> </li> <li>ontologies : explicit specification of a conceptualization of the real world, proxy representation (annotation) <ul> <li>ontology engineering : manual effort, edit and check</li> <li>automatic induction : from large document collections</li> <li>modeling/encoding : what does an arrow/instance-of/ISA mean? use tag attribute to reference the concept <img src="./assets/img/cs423-9.jpg" alt=""> </li> </ul> </li> </ul> </li> </ul> <h3 id="rdf-resource-description-framework">RDF resource description framework</h3> <ul> <li>resource decription framework : RDF, graph oriented data model to annotate any kind of XML document, similar to ER model <img src="./assets/img/cs423-9.0.jpg" alt=""> <ul> <li>statements : about resources (URI-addressable) and literals (XML data)</li> <li>resource form : subject (URI) property object (URI or string)</li> <li>RDF statement : also resources</li> <li>properties : define relationship to other resources or atomic values</li> <li>schema : grammar and vocabulary for semantic domains</li> <li>containers : bag (unordered multi-set), seq (ordered), alt (alternatives, single resource chosen out of given set) <img src="./assets/img/cs423-9.01.jpg" alt=""> </li> <li>typing resources : special property rdf:type</li> <li>new resources : special property rdf:ID</li> <li>quantifiers : about, aboutEach</li> <li>reification : introduce resources which serves as representative for a statement <img src="./assets/img/cs423-9.02.jpg" alt=""> </li> </ul> </li> <li>RDF schema <ul> <li>categorization : into classes</li> <li>constraints : possible uses of properties (connect resources) <ul> <li>domaines : classes of which instances may have a property</li> <li>range : classes of which the instances may be the value of a property <img src="./assets/img/cs423-9.1.jpg" alt=""> <img src="./assets/img/cs423-9.2.jpg" alt=""> </li> </ul> </li> <li>inheritance <ul> <li>A subClassOf B : transitive, not reflexive, anti-symmetric (no cycle), many subclass and superclass, subclass inherit all properties of superclass</li> <li>P1 subPropertyOf P2 : if A has property P1 with value B then it has value B with property P2</li> </ul> </li> </ul> </li> <li>classification <img src="./assets/img/cs423-10.jpg" alt=""> </li> </ul> <h3 id="semantic-web-resources">Semantic web resources</h3> <ul> <li>sematic web resources : wikidata, google knowledge graph, lined open data example, multi-encoding (json, rdf) <ul> <li>wordnet : synonymy/antonymy, herpnymy (hierarchical relationship between words)/hyponymy, meronymy (part-whole relationship, e.g. paper and book)</li> <li>schema.org : big companies behind</li> </ul> </li> </ul> <h3 id="onotology-languages">Onotology languages</h3> <ul> <li>ontology languages : OWL, well designed, well defined, compatible with RDF, rich compared to RDF <ul> <li>description logics (DL) : fragment of first order predicate logic (FOL), reasoning can be done, describe knownledge in term of concepts and role restrictions used to automatically derive classification taxonomies <img src="./assets/img/cs423-11.jpg" alt=""> </li> <li>frame-based systems : central modeling primitive classes with attributes</li> <li>web standards : XML, RDF</li> <li>class constructor : intersectionOf, unionOf, complementOf, oneOf, allValuesFrom, someValuesFrom, maxCardinality, minCardinality <img src="./assets/img/cs423-12.jpg" alt=""> </li> <li>OWL axioms <img src="./assets/img/cs423-13.jpg" alt=""> </li> <li>OWL lite : subset of OWL, easy to omplement</li> <li>OWL DL : restriction to FOL fragment, mixing of RDFS and OWL restricted, disjointness of classes, properties, individuals and data values</li> <li>OWL Full : union of OWL syntax and RDF, no restriction</li> </ul> </li> </ul> <h3 id="information-extraction">Information extraction</h3> <ul> <li>populating knowledge bases automatically : extract knowledge from documents, challenge natural language <ul> <li>concept : ideas or concrete entities, relationship</li> <li>identifying : explicit (twitter tag, keywords) or extract</li> </ul> </li> <li>key phrase extraction : automatic selection of important and topical phrases fro document body <ul> <li>candidate phrases : removing stop word, use word n-grams, part-of-speech</li> <li>baseline ranking approach : ranking according to tf-idf</li> <li>advanced approach : use many structural, syntactic document features, external resources</li> </ul> </li> <li>named entity recognition : find and classify names of people, organizations, places, brands mentionned in documents <ul> <li>uses : sentiment attributed to produtcts, anchors</li> <li>sequence labelling task : classification, predict next label, naive bayes, HMM, MEEM, CRF <ul> <li>features : neighboring words, preceding labels, POS, prefix, suffix, wird shape</li> </ul> </li> <li>generative probabilistic model : words (known) $W=(w_1,\ldots,w_n)$, states (unknown) $E=(e_1,\ldots,e_n)$ <ul> <li>assume text produced : $P(E,W)$</li> <li>model : $\arg\max_E P(E\mid W)=\arg\max_E P(E)P(W\mid E)$</li> <li>transition probabilities : bigram model, $P(E)\approx \Pi_{i=2,\ldots, n} P_E(e_i\mid e_{i-1})$, $P_E(e_i\mid e_{i-1})$ estimated by maximum likelihood</li> <li>word emission probailities : $P(W\mid E)\approx\Pi_{i=1,\ldots,n}P_W(w_i\mid e_i)$, $P_W(w_i\mid e_i)$</li> </ul> </li> <li>smoothing : unseen words might only miss in training set, $P_{WS}(w_i\mid e_i)=\lambda P_W(w_i\mid e_i)+(1-\lambda)\frac{1}{n}$</li> </ul> </li> <li>information extraction : extract structured information from text <ul> <li>statement : IS-A, RELATED-TO, DEPENDS-ON, LOCATED-IN</li> <li> <p>typed statements : between types, PART-OF, RELATED-TO, LOCATED-IN</p> </li> <li> <table> <tbody> <tr> <td>hand-written pattern : “Y such as X ((, X)* (, and</td> <td>or) X)”, NER then “cures(DRUG, DISEASE)”, high-precision, tailored to specific domains, human low recall</td> </tr> </tbody> </table> </li> <li>supervised machine learning <ul> <li>training set : hard to create, choose relevant NER and relations, use unlabeled entity pairs as negative samples</li> <li>classifier : naives bayes, filtering classifier (detect whether relation exists among entities), relation-specific classifier (detect relation label)</li> <li>features : bag of words, bigrams, headword, stems, types, syntactic features, parse tree</li> </ul> </li> <li>bootstrapping : no training data, few high-precision patterns, find entity pairs that match pattern, find sentences containing those, generalize entities and generate new patterns</li> <li>semantic drift : LOC hostels, LOC but geneva not located in lausanne</li> <li>confidence : confirmed set of pairs of mentions $M$, $conf(p)=\frac{hits_p}{finds_p}\log(finds_p)$ <ul> <li>$hits_p$ : set of tuples in $M$ that new pattern matches</li> <li>$finds_p$ : total set of tuples that new pattern matches</li> </ul> </li> <li>distant supervision : no training data, use large corpus to collect training data, classify to predict label from other sources, high precision but low recall, feasible, match only if all individual features match</li> </ul> </li> </ul> <h3 id="taxonomy-induction">Taxonomy induction</h3> <ul> <li>taxonomy induction : extract related facts from documents (classification of animals), not unique <ul> <li>hyponyms : subordinate terms, can inherit properties from hypernyms (more general terms)</li> <li>ISA : no need to learn inferred facts as transitive</li> <li>task : start from root/basic concept <ul> <li>learn relevant terms : hypernym/hyponym relationship</li> <li>filter out : erroneous terms and relation</li> <li>induce : taxonomy structure<br> <img src="./assets/img/cs423-14.jpg" alt=""> </li> </ul> </li> <li>learning hypernym <img src="./assets/img/cs423-15.jpg" alt=""> </li> <li>inducing hypernym graph : many possible relationships among concepts and terms not likely to be discovered <img src="./assets/img/cs423-16.jpg" alt=""> </li> <li>cleaning hypernym graph : determine all basic concept (not hypernym of another concept), determine all root concepts (no hypernyms), for each basic root concept pair, select all hypernym paths that connect them, choose longest one for final taxonomy</li> </ul> </li> </ul> <h3 id="schema-integration">Schema integration</h3> <ul> <li>keys task in distributed information management : more data ? more models ? more useful information ? supply vs demand ?, interpretation and different views of data source</li> <li>schema matching : integration of heterogeneous data sources <img src="./assets/img/cs423-16.1.jpg" alt=""> <ul> <li>manual : common practice today</li> <li>tools : based on structural and content features, estiablish correspondences and rank according to quality (error frequent and unavoidable)</li> <li>universe of database : universe $U$ finite set of possible instances</li> <li>similarity of classes : $A$, $B$ classes (subsets of $U$), jaccard $sim(A,B)=\frac{\abs{A\cap B}}{\abs{A\cup B}}=\frac{P(A,B)}{P(A,B)+P(\bar A,B)+P(A,\bar B)}$, does not work when information has structurally different representation <img src="./assets/img/cs423-16.2.jpg" alt=""> </li> <li>classes : intension is similar (instance), extension is different, complex features <ul> <li>attributes and relationship names</li> <li>structural relationship : data types</li> <li>distribution features : data values</li> <li>content features : text <img src="./assets/img/cs423-17.jpg" alt=""> </li> </ul> </li> <li>finding corresponding classes : $U1$ (DB1) and $U2$ (DB2), $U1\cap U2=\emptyset$ <ul> <li>probabilistic approach : give instance $i$ with feature $T_i$ belong to class $A$ <ul> <li>naives bayes : $P(A\mid T_i)=P(T_i\mid A)P(A)P(d)\propto P(T_i\mid A)P(A)$</li> <li>known : $P(A)=\frac{\abs{A}}{\abs{U_1}}$</li> <li>independence assumption $P(T_i\mid A)=P(t_1\mid A)\cdots P(t_n\mid A)$</li> <li>$T_A$ being bag of all terms in all instances of $A$ : $P(t\mid A)=\frac{\abs{t\in T_A}}{\sum_{t’}\abs{t’\in T_A}}$ <img src="./assets/img/cs423-18.jpg" alt=""> <img src="./assets/img/cs423-19.jpg" alt=""> </li> </ul> </li> </ul> </li> </ul> </li> <li>node mapping : alternative class mapping <ul> <li>naive approach : order matchings by probability, choose most probable matching, produce mapping among the classes, remove mapped classes, choose next most probable matching and repeat, consistency constraints may be violated</li> </ul> </li> </ul> <h3 id="networked-schema-integration">Networked schema integration</h3> <ul> <li>data integration networks : different experts may contribute input on schema matching</li> <li>wisdom of network : leverage knowledge from network <ul> <li>pay-as-you-go schema matching : generate probabilistic matching network (pSMN), keep all potential mappings and assess probability of correctness <img src="./assets/img/cs423-19.1.jpg" alt=""> </li> <li>matching instances : consistency constraints satisfied, drop as little knowledge as possible <ul> <li>uniqueness : attribute cannot be mapped to two different attributes</li> <li>transitivity</li> <li>maximal : minimal number of claimed correspondences removed</li> <li>probability of correctness $p_c$ with correspondence $c$ : $p_c=\frac{\text{#number of matching instances that contain c}}{\text{#total number of matching instances}}$, high complexity computation, use non-uniform sampling for efficient approximation <img src="./assets/img/cs423-19.2.jpg" alt=""> </li> </ul> </li> <li>reducing network uncertainty : $H( C)=-\sum_{k\in C}p_c\log p_c+(1-p_c)\log(1-p_c)$ with information gain $IG( C)=H( C)-H(C\mid c)$</li> <li>selecting best matching instance : after obtaining user feedback, find matching instance with minimal repair distance (dropping as few correspondence as possible), maximal likelihood ($\Pi_{c\in C}p_c$) <img src="./assets/img/cs423-20.jpg" alt=""> </li> </ul> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Lexical-Analysis,-Syntax-Analysis,-and-Semantic-Analysis-copy/">Lexical Analysis, Syntax Analysis, and Semantic Analysis</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Rust-Basics-1(Quick-Review)/">Rust Basics 1(Quick Review)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/Signature-Algorithm/">Signature Algorithm 数字签名算法</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/DIS-Classification/">DIS - Classification</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/Software-Security-1-(Basic-Principles)/">Software Security 1 (Basic Principles)</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Tianchi YU. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>