<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>DIS - Classification | Tianchi YU</title> <meta name="author" content="Tianchi YU"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.ico"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://lialittis.github.io/blog/2020/DIS-Classification/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">TianchiÂ </span>YU</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">GitRepos</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">DIS - Classification</h1> <p class="post-meta">June 11, 2020â€¢ TC YU</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fas fa-calendar fa-sm"></i> 2020 </a> Â  Â· Â  <a href="/blog/tag/data-mining"> <i class="fas fa-hashtag fa-sm"></i> Data Mining</a> Â  <a href="/blog/tag/distributed-information-system"> <i class="fas fa-hashtag fa-sm"></i> Distributed Information System</a> Â  </p> </header> <article class="post-content"> <div id="markdown-content"> <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script> <h1 id="dis---classification">DIS - Classification</h1> <h2 id="clustering-and-classificatioin">Clustering and Classificatioin</h2> <p>For inferring global models of data collections there exist two types of approaches: descriptive and predictive modeling. We illustrate the difference among them by an example.</p> <p>We assume that a set of data items (or objects) with two attributes a1 and a2 is given. Assume the global model we are interested in is a classification (or as often said labeling) of the data items. In descriptive modeling we just know the data items, as indicated by the points in the 2-dimensional grid. A descriptive modeling technique, such as clustering, produces classes, which are not known in advance. For doing this it relies on some criteria that specify when two data items probably belong to the same class. Such a criteria is usually based on a similarity measure.</p> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/DIS_Clustering.png" alt=""></p> <p>A predictive modeling technique, such as classification, starts from a given classification (or labeling) of data items. Using that classification of the dataset the classification method infers conditions on the properties of the data objects, that allow to predict the membership to a specific class. For example, the prediction could be based on a partitioning of the attribute values along each dimension, as shown in the figure on the right. There, first attribute a1 is partitioned into two intervals, and for each of the intervals a different partitioning of the attribute a2 is used to determine the regions corresponding to classes. Misclassifications may occur as seen in the example.</p> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/DIS_Classification.png" alt=""></p> <ul> <li><strong>Given a dataset of objects described by attributes, build a model that assigns objects to a class (or label)</strong></li> </ul> <p>no class info -&gt; descriptive model(clustering) -&gt; describe classes based on similarity of attribute values</p> <ul> <li><strong>Given a dataset of objects described by attributes, build a model that assigns objects to a class</strong></li> </ul> <p>class info -&gt; predictive model(classification) -&gt; predict classes based on known attribute values</p> <h2 id="classification-problem">Classification Problem</h2> <p>Classification creates a <strong>global model</strong>, that is used for predicting the class label of unknown data. Since the classification function is learned from existing data, this approach is also called a <strong>supervised learning approach</strong>.</p> <p>Classification is clearly useful in many decision problems, where for a given data item a decision is to be made (which depends on the class to which the data item belongs). Classification is also often called <strong>predictive analytics</strong>.</p> <p>Input: set of objects with <strong>categorical/numerical attributes</strong> and one <strong>class label</strong></p> <p>Output: A model that returns the class label given the object attributes</p> <ul> <li>Model is a function represented as rules, decision trees, formulae, neural networks</li> </ul> <p><strong>Classification belongs to supervised ML</strong></p> <ul> <li>Objects have class information</li> </ul> <h2 id="basic-approach">Basic Approach</h2> <p>Model is learnt from a set of objects with known labels: <strong>training set</strong></p> <p>The quality of the model is evaluated by comparing the predicted class labels with those from a set of objects with known labels: <strong>test set</strong></p> <ul> <li>Test set is independent of training set, otherwise over-fitting will occur</li> </ul> <p>The model is applied to data with unknown labels: <strong>prediction</strong></p> <h3 id="example-of-classification">Example of Classification</h3> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/example_classification.png" alt=""></p> <h4 id="model-test-and-usage">Model test and Usage</h4> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/model_test.png" alt=""></p> <h2 id="problem-formulation">Problem formulation</h2> <p>Problem: Given a database D with n data items described by d categorical/numerical attributes and one categorical attribute (class label C)</p> <p>Find:(rules, decision tree,â€¦)</p> <p>A function f: $X^d -&gt; C$</p> <p>Such that: classifies accurately the items in the training set generalises well for the (unknown) items in the test set</p> <h2 id="characteristics-of-classification-methods">Characteristics of Classification Methods</h2> <ul> <li>Predictive accuracy</li> <li>Speed and scalability <ul> <li>Time to build the model(usually more expensive)</li> <li>Time to use the model</li> <li>In memory vs. on disk proceesing</li> </ul> </li> <li>Robustness <ul> <li>Handling noise, outliers and missing values</li> </ul> </li> <li>Interpretability [å¯è§£é‡Šæ€§] <ul> <li>Understanding the model and its decisions(black box) vs. white box</li> <li>Compactness of the model [ç®€æ´æ€§]</li> </ul> </li> </ul> <p>As for clustering methods, we can also identify for classification methods a range of criteria to assess and compare the properties of different approaches.</p> <p>Predictive accuracy is the natural main objective to optimize for a classifier. It characterizes how well the classifier performs its job. Often we encounter a trade off between predictive accuracy and the speed and scalability of the method. Methods that achieve high accuracy tend also to be more expensive. As for clustering, also for classification noise and outliers can pose additional problems affecting accuracy. Finally, a very important criterion is the interpretability of the model. In many concrete applications, it is critical that humans are able to understand based on which criteria a classifier takes a decision, e.g. for accountability. Imagine a case, where an assurance policy is refused based on the decision taken by a classifier, and the client would oppose in court. Only with human-interpretable methods the decision could be argued for. However, the most powerful classifiers today tend to produce models that are very hard to interpret for humans, as they represent very complex functions.</p> <h2 id="qa">Q&amp;A</h2> <p>If a classifier has 75% accuracy, it means that â€¦</p> <p>A. It correctly classifies 75% of the data items in the training set</p> <p>B. It correctly classifies 100% of the data items in the training set but only 75% in the test set</p> <p>C. It correctly classifies 75% of the data items in the test set</p> <p>D. It correctly classifies 75% of the unknown data items</p> <p>Answer: [&lt;font color: white&gt; C &lt;/font&gt;]</p> <h2 id="decision-trees">Decision Trees</h2> <ul> <li> <strong>Nodes</strong> are tests on a single attribute</li> <li> <strong>Branches</strong> are attribute values</li> <li> <strong>Leaves</strong> are marked with class labels</li> </ul> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/DIS_Decision_Tree.png" alt=""></p> <p>A standard type of classification function is a decision tree. In a basic decision tree, <strong>at each level one of the available attributes is used to partition the data set based on the different attribute values</strong>. At the leaf level of the decision tree, the values of the class label attribute are found. Thus, for a given data item with unknown class label attribute, by traversing the tree from the root to the leaf according to its data values, its class can be determined by choosing the class label found at the leaf level. Note that in different branches of the tree, different attributes may be used for classification.</p> <p>A decision tree is constructed in a top-down manner, by recursively splitting the training set using conditions on the attributes. How these conditions are determined is one of the key questions for decision tree induction. After the decision tree construction, it may occur that at the leaf level the granularity is too fine, i.e., many leaves correspond to outliers in the data. Thus, in a second phase such leaves are identified and eliminated.</p> <p>The key problem in constructing a decision tree is thus to determine the attributes that are used to partition the data set at each level of the decision tree.</p> <h3 id="decision-tree-induction-algorithm">Decision Tree Induction: Algorithm</h3> <p><strong>Tree construction (top-down divide-and-conquer strategy)</strong></p> <ul> <li>At the beginning, all training samples belong to the root</li> <li>Examples are partitioned recursively based on a selected â€œmost discriminativeâ€ attribute</li> <li>Discriminative power determined based on <strong>information gain (ID3/C4.5)</strong> </li> </ul> <p><strong>Partitioning stops if</strong></p> <ul> <li>All samples belong to the same class â†’ assign the class label to the leaf</li> <li>There are no attributes left â†’ majority voting to assign the class label to the leaf</li> <li>There are no samples left</li> </ul> <p>The basic algorithm for decision tree induction proceeds in a greedy manner. First the set of all data objects are associated with the root. Among all attributes one is chosen to partition the set. The criterion that is applied to select the attribute is based on measuring the <strong>information gain</strong> that can be achieved, or how much uncertainty on the classification of the data objects is removed by the partitioning.</p> <p>Three conditions can occur such that no further partitions can be performed:</p> <p>(1) all data objects are in the same class, therefore further splitting makes no sense,</p> <p>(2) no attributes are left which can be used to split. Still data objects from different classes can be in the leaf, then majority voting is applied.</p> <p>(3) no data objects are left.</p> <h3 id="example">Example</h3> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/example_decision_tree.png" alt=""></p> <p>Based on this approach for attribute selection, we can now illustrate the induction of the decision tree. In a first step, age is chosen for a split. The partition 31..40 contains after the split only instances from one class, the positive class, thus for this branch of the tree the induction terminates.</p> <p>For the partition &lt;= 30 we find that the student attribute is the best to be chosen for further splitting. Further splitting makes no more sense, as the two resulting partitions, after splitting by the student attribute, are consisting of either positive or negative instances only.</p> <p>Similarly, for the partition &gt;40 we find that credit rating gives the largest information gain. As before, further splitting is no more needed, as the resulting partitions contain only positive respectively negative instances.</p> <h2 id="attribute-selection">Attribute Selection</h2> <h3 id="entropy">Entropy</h3> <p>At a given branch in the tree, the set of samples S to be classified has P positive and N negative instances</p> <p>The entropy of the set S is</p> \[H(P,N) = -\frac{P}{P+N}log_2\frac{P}{P+N} - \frac{N}{P+N}log_2\frac{N}{P+N}\] <ul> <li>Note:</li> </ul> <p>If P = 0 or N = 0, then H(P,N) = 0 -&gt; no uncertainty</p> <p>If P = N, then H(P,N) = 1 -&gt; maximal uncertainty</p> <blockquote> <p>The approach is based on an information-theoretic argument. Assuming that we have a binary category, i.e., two classes P and N to which objects in S have to be assigned, we can compute the amount of information required to determine the class, by H(P, N), the standard entropy measure, where P and N denote the cardinalities of the classes P and N. Given an attribute A that can be used for partitioning the data collection, we can calculate the amount of information needed to classify the data after the split according to attribute A has been performed. This value is obtained by calculating H(P, N) for each of the partitions and weighting these values by the probability that a data item belongs to the respective partition.</p> </blockquote> <h4 id="example-1">Example</h4> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/example_attribute_selection.png" alt=""></p> <p>We illustrate the attribute selection process now for our running example. Initially the data contains P = 9 positive instances and N = 5 negative instances. This results in an entropy of 0.94, i.e. 0.94 bits are required to decide the class of one instance. We compute next the entropies of all partitions that result from splitting all attributes. For example, if we split for Age, we obtain 3 partitions, each with a different distribution of positive and negative instances; and thus with different entropies.</p> <h3 id="information-gain">Information Gain</h3> <p>The information gained by a split can thus be determined as the difference of the amount of information needed for correct classification before and after the split. Thus we calculate the reduction in uncertainty that is obtained by splitting according to attribute A and select among all possible attributes the one that leads to the highest reduction. For our example we can conclude that it is best to split on attribute age.</p> <p>Next we compute the weighted sum of all entropies of the partitions in a split. The weights correspond to the probability of an instance falling into an element of the partition. Computing this for all attributes shows, that the attribute H results in the lowest entropy, i.e., leaves the lowest remaining uncertainty about the class membership of instances after the split.</p> <ul> <li>Computation</li> </ul> <p>Attribute A partitions S into $S_1, S_2, â€¦ S_v$ Entropy of attribute A is \(H(A) = \sum_{i=1}^v\frac{P_i+N_i}{P+N}H(P_i,N_i)\)</p> <p>The information gain obtained by splitting S using A is \(Gain(A) = H(P,N) - H(A)\) Choose the biggest information gain as the splited one.</p> <h3 id="q--a">Q &amp; A</h3> <p>Given the distribution of positive and negative samples for attributes A1 and A2, which is the best attribute for splitting?</p> <table> <thead> <tr> <th>A1</th> <th>P</th> <th>N</th> </tr> </thead> <tbody> <tr> <td>a</td> <td>2</td> <td>2</td> </tr> <tr> <td>b</td> <td>4</td> <td>0</td> </tr> </tbody> </table> <table> <thead> <tr> <th>A2</th> <th>P</th> <th>N</th> </tr> </thead> <tbody> <tr> <td>x</td> <td>3</td> <td>1</td> </tr> <tr> <td>y</td> <td>3</td> <td>1</td> </tr> </tbody> </table> <p>Answer:[<font color:white="">A1</font>]</p> <h2 id="pruning-ä¿®å‰ª">Pruning [ä¿®å‰ª]</h2> <blockquote> <p>A common problem in classification is that a classifier may <strong>overspecialize and capture noise and outliers in the data</strong>[å™ªå£°å’Œç¦»ç¾¤å€¼å¯¹æ•°æ®çš„å½±å“], rather than <strong>general properties</strong>. One possibility to limit overspecialization would be to <strong>stop the partitioning of tree nodes when some specific criteria is met</strong> (e.g., number of samples assigned to the leaf node). A possible criterion is to <strong>stop partitioning when the majority of remaining samples falls into one class</strong>. However, in general it is difficult to specify a suitable criterion a priori (e.g. choosing the right value of epsilon).</p> </blockquote> <blockquote> <p>Another alternative is to <strong>first build the complete classification tree</strong>, and then, in a second phase, <strong>prune subtrees that do not contribute to an efficient classification</strong>. Different approaches can be applied to that end: <strong>heuristic approaches[å¯å‘å¼æ–¹æ³•] can identify subtrees that do not contribute to the classification accuracy, and eliminate those</strong>. A more principled approach is <strong>the use of the minimum description length principle</strong>. (MDL).</p> </blockquote> <p>The construction phase does not filter out noise â†’ <strong>overfitting</strong></p> <p>Pruning strategies</p> <ul> <li> <p>Stop partitioning a node when large majority of samples is positive or negative, i.e., ğ‘/(ğ‘+ğ‘ƒ) or ğ‘ƒ/(ğ‘+ğ‘ƒ)&gt;1âˆ’ğœ€</p> </li> <li> <p>Build the full tree, then replace nodes with leaves labelled with the majority class, if classification accuracy does not change</p> </li> <li> <p>Apply Minimum Description Length (MDL) principle</p> </li> </ul> <p>åˆ†ç±»ç®—æ³•ï¼š https://blog.csdn.net/china1000/article/details/48597469</p> <h3 id="minimum-description-length-pruning">Minimum Description Length Pruning</h3> <p>The MDL is based on the following consideration: if the effort in order to specify a class (the implicit description of the class extension through a decision tree) exceeds the effort to enumerate all class members (the explicit description of the class by enumerating its extension), then the subtree is over classifying and non-optimal. To measure the description cost a suitable metrics for the encoding cost, both for trees and data sets is required. For trees this can be done by suitably counting the various structural elements needed to encode the tree (#nodes, #test predicates, # arcs), whereas for explicit classification, it is sufficient to count the number of misclassifications that occur in a tree node.</p> <p>è¡¥å……ï¼š å‰ªæçš„ç›®çš„æ˜¯ä¸ºäº†é€šè¿‡åˆ é™¤éƒ¨åˆ†èŠ‚ç‚¹å’Œå­æ ‘ï¼Œä»¥é¿å…â€œè¿‡åº¦åˆé€‚â€/â€œè¿‡å­¦ä¹ â€ï¼Œå› ä¸ºè¿‡å­¦ä¹ å°†å¯¼è‡´æˆ‘ä»¬ä½œå‡ºçš„å‡è®¾çš„æ³›åŒ–èƒ½åŠ›è¿‡å·®ã€‚æœ€å°æè¿°é•¿åº¦ï¼ˆMDLï¼‰å‡†åˆ™è¡¨ç¤ºï¼Œè§£é‡Šä¸€ç»„æ•°æ®æœ€å¥½çš„ç†è®ºï¼Œåº”è¯¥ä½¿ä¸‹é¢è¿™ä¸¤é¡¹ä¹‹å’Œæœ€ä¸‹ï¼š</p> <ol> <li>æè¿°ç†è®ºæ‰€éœ€è¦çš„æ¯”ç‰¹é•¿åº¦ï¼›</li> <li>åœ¨ç†è®ºçš„ååŠ©ä¸‹ï¼Œå¯¹æ•°æ®ç¼–ç æ‰€éœ€è¦çš„æ¯”ç‰¹é•¿åº¦ã€‚</li> </ol> <p>è€Œå†³ç­–æ ‘ä¸­çš„MDLåº”å½“æ˜¯ä½¿å¾—è®­ç»ƒæ ·æœ¬çš„å¤§å¤šæ•°æ•°æ®ç¬¦åˆè¿™æ£µæ ‘ï¼Œå…¶ä»–çš„æ ·æœ¬ä½œä¸ºä¾‹å¤–ç¼–ç ï¼Œä½¿å¾—ä¸‹é¢è¿™ä¸¤é¡¹æœ€å°ï¼š</p> <ol> <li>ç¼–ç å†³ç­–æ ‘æ‰€éœ€è¦çš„æ¯”ç‰¹ï¼Œå®ƒä»£è¡¨äº†çŒœæƒ³</li> <li>ç¼–ç ä¾‹å¤–å®ä¾‹æ‰€éœ€è¦çš„æ¯”ç‰¹</li> </ol> <p>Let M1, M2, â€¦, Mn be a list of candidate models (i.e., trees). The best model is the one that minimizes \(L(M) + L(D|M)\) where</p> <ul> <li> <p>L(M) is the length of the description of the model in bits (#nodes, #leaves, #arcs â€¦)</p> </li> <li> <table> <tbody> <tr> <td>L(D</td> <td>M) is the is the length of the description of the data when encoded with the model in bits (#misclassifications)</td> </tr> </tbody> </table> </li> </ul> <h2 id="continuous-attributes">Continuous Attributes</h2> <p>With continuous attributes it does not make sense to create a separate path in the decision tree for every possible attribute value. Instead, in such a case, a binary decision tree is constructed. Binary decisions can be specified both for continuous and categorical attributes. For continuous attributes, the binary split is performed by selecting a threshold that separates the instances in those that have a larger and a smaller value than the threshold. For categorical attributes, a subset of attribute values can be chosen that distinguishes the instances in two subsets.</p> <p>With continuous attributes we cannot have a separate branch for each value</p> <ul> <li>use binary decision trees</li> </ul> <p>Binary decision trees</p> <ul> <li>For continuous attributes A a split is defined by val(A) &lt; X</li> <li>For categorical attributes A a split is defined by a subset X $\subseteq$ domain(A)</li> </ul> <h3 id="example-2">Example</h3> <p>This example shows a dataset with both categorical and continuous attributes and a possible binary decision tree for such a dataset. The class label in the example is Risk.</p> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/example_binary_bt.png" alt=""></p> <h3 id="splitting-continuous-attributes">Splitting Continuous Attributes</h3> <p>Approach</p> <ul> <li>Sort the data according to attribute value</li> <li>Determine the value of X which maximizes information gain by scanning through the data items</li> </ul> <p>Only if the class label changes, a relevant decision point exists</p> <blockquote> <p>When splitting the dataset using a continuous attribute, we need to determine which is the optimal value to split the dataset based on this attribute. To that end, first the set of attribute values is sorted. Then the class labels are traversed, and whenever it changes a possible split point is found (it can be shown that splitting where class labels do not change is provably sub-optimal). At these points the information gain needs to be computed.</p> </blockquote> <h4 id="scalability-of-continuous-attributes">Scalability of Continuous Attributes</h4> <p>Naive implementation</p> <ul> <li>At each step the data set is split in subsets that are associated with a tree node</li> </ul> <p>Problem</p> <ul> <li>For evaluating which continuous attribute to split, data needs to be sorted according to these attributes</li> <li>Becomes dominating cost</li> </ul> <p>In a naÃ¯ve implementation of the splitting process, we would keep all data in a single table. This would imply that we would have for traversing the attributes in order to resort that table every time an attribute is investigated. Therefore, a more efficient approach is needed.</p> <blockquote> <p>To avoid repeated resorting of data, for every attribute a separate and presorted table is kept. Once a split is chosen, we find two different situation. For the table that keeps the attribute that was used in the split, the table needs just to be partitioned into two subtables, maintaining the order. For the other attributes we have to select the subtables corresponding to the instances of the two partitions that have been formed. To that end a temporary hash table is constructed that allows to associate to each dataitem its partition. Then the attribute table is scanned and partitioned using the hashtable to decide for each entry to which partition it belongs. Note that in this approach, for continuous attributes, the resulting tables are again sorted as the order is preserved from the original table.</p> </blockquote> <p><strong>Idea: Presorting of data and maintaining order throughout tree construction</strong></p> <ul> <li>Requires separate sorted attribute tables for each attribute</li> </ul> <p>Updating attribute tables</p> <ul> <li>Attribute used for split: splitting attribute table straightforward</li> <li>Other attributes <ul> <li>Build Hash Table once associating tuple identifiers (TIDs) of data items with partitions</li> <li>Select data from other attribute tables by scanning and probing the hash table</li> </ul> </li> </ul> <h3 id="example-3">Example</h3> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/example_continuous_splits.png" alt=""></p> <p>In this example we demonstrate of how attribute tables are split, when a decision node is introduced in the decision tree. Since the split is based on attribute Age, the table for Age can simply be split into two subtables at the threshold value. For the Car Type table we use the temporary hash table indicating partition membership to separate it into two subtables.</p> <h3 id="q--a-1">Q &amp; A</h3> <p>When splitting a continuous attribute, its values need to be sorted â€¦</p> <p>A. to avoid overfitting</p> <p>B. to prune the data</p> <p>C. to define a binary split condition</p> <p>D. to accelerate tree induction</p> <p>Answer:[<font color:white="">C</font>]</p> <h2 id="characteristics-of-decision-tree-induction">Characteristics of Decision Tree Induction</h2> <p>We summarize here some of the major strengths and weaknesses of standard decision tree induction.</p> <p><strong>Decision trees advantages</strong></p> <ul> <li>The information theoretic criteria used to select the most discriminative attribute is an embedded feature selection</li> <li>No data preparation is needed, such as normalisation of data</li> <li>The best aspect of using trees for analytics is that they are easy to interpret and explain, while more sophisticated ML algorithms (ANN, SVM) are seen as black-boxes that do not â€œexplainâ€ the classification decisions they make</li> </ul> <p><strong>Decision trees drawbacks</strong></p> <ul> <li>They can be extremely sensitive to small perturbations in the data: a slight change can result in a drastically different tree.</li> <li>They can easily overfit. This can be compensated by validation methods and pruning, but remains a problem.</li> <li>They are not incremental. If new data is available, the existing tree cannot be incrementally modified, but the whole tree must be reconstructed from scratch</li> </ul> <hr> <p>Strengths</p> <ul> <li>Automatic feature selection</li> <li>Minimal data preparation</li> <li>Non-linear model</li> <li>Easy to interpret and explain</li> </ul> <p>Weaknesses</p> <ul> <li>Sensitive to small perturbation in the data</li> <li>Tend to overfit</li> <li>No incremental updates</li> </ul> <hr> <h3 id="decision-tree-induction-properties">Decision Tree Induction: Properties</h3> <p>Model: flow-chart like tree structure</p> <p>Score function: classification accuracy</p> <p>Optimisation: top-down tree construction + pruning</p> <p>Data Management: avoiding sorting during splits</p> <h2 id="classification-algorithms">Classification Algorithms</h2> <p>Decision trees is one of the best known and historically first examples of a classification approach. Many other methods have been devised in studied over tie. These include basic methods (we will see some examples later), ensemble methods (discussed in the following), support vector machines (a paradigm based on splitting the space through hyper-planes), and neural networks (which are attracting recently significant attention and are nowadays among the best performing classifiers if very large training sets are available).</p> <p>Decision tree induction is a (well-known) example of a classification algorithm</p> <p>Alternatives</p> <ul> <li>Basic methods: NaÃ¯ve Bayes, kNN, logistic regression, ..</li> <li>Ensemble methods: random forest, gradient boosting, â€¦</li> <li>Support vector machines</li> <li>Neural networks: CNN, rNN, LSTM, â€¦</li> </ul> <h3 id="ensemble-methods">Ensemble Methods</h3> <p>One important development in decision trees was the introduction of the idea of ensemble methods. The basic principle is simple: instead of constructing a single model, many different models are constructed independently. Even if each model is not very expressive (weak learners) their combination can be powerful (strong learner). Different ensemble methods are distinguished by the type of approach they are based on. Ensemble methods, which we will discuss in the following, learn several models in parallel, and combine then their predictions by voting or averaging. Stacking methods use more sophisticated techniques to combine model outputs, based themselves on learning methods. Finally, boosting learn models in sequence. In each step the samples of the training data are reweighted depending on whether they have been correctly classified.</p> <p>Idea</p> <ul> <li>Take a collection of simple or weak learners</li> <li>Combine their results to make a single, strong learner Types</li> <li>Bagging: train learners in parallel on different samples of the data, then combine outputs through voting or averaging</li> <li>Stacking: combine model outputs using a second-stage learner like linear regression[çº¿æ€§å›å½’]</li> <li>Boosting: train learners on the filtered output of other learners</li> </ul> <h3 id="random-forests-algorithm">Random Forests: Algorithm</h3> <p>Random forests are an ensemble method based on bagging. The principle is very simple: K different decision trees are learnt in parallel from different (independent) samples of the data, and the classification is derived from a majority vote of the predictions.</p> <p>Learn K different decision trees from independent samples of the data (bagging); vote between different learners, so models should not be too similar</p> <p>Aggregate output: majority vote</p> <h4 id="why-do-ensemble-methods-work">Why do Ensemble Methods Work?</h4> <p>Here we give the argument why ensemble methods work: even if the individual classifiers are not very good (e.g. make 35% errors in prediction) their aggregate will be very strong. For example, if we have 25 classifiers, the probability that a majority of them, namely at least 13, make a wrong prediction is very small, namely 6%. In general, ensemble methods work well, if the individual models are better than random guessing. The figure illustrates the relation between the classification errors of individual classifiers and the aggregate classification accuracy.</p> <h4 id="sampling-strategies">Sampling Strategies</h4> <p>Two sampling strategies</p> <p>Sampling data</p> <ul> <li>select a subset of the data â†’ Each tree is trained on different data</li> </ul> <p>Sampling attributes</p> <ul> <li>select a subset of attributes â†’ corresponding nodes in different trees (usually) donâ€™t use the same feature to split</li> </ul> <p>For random forests the main issue is the choice of the sampling strategy, i.e., the generation of samples that are used for learning the individual models. Specifically, it consists of two different sampling strategy. The first, sampling data selects from the original dataset a sample. Thus each decision tree is trained on a different sample of data. The second, sampling attributes selects from the attributes available to take a decision a random subset. Thus even if a tree would have been constructed in the same way up to a level, the continuation might become different due to attribute sampling (e.g. the optimal attribute in one tree is not available for splitting in the other tree).</p> <h4 id="algorithm-context">Algorithm context</h4> <ol> <li>Draw K bootstrap samples of size N from original dataset, with replacement (bootstrapping)</li> <li>While constructing the decision tree, select a random set of m attributes out of the p attributes available to infer split (feature bagging)</li> </ol> <p>Typical parameters</p> <ul> <li>m â‰ˆ sqrt(p), or smaller</li> <li>K â‰ˆ 500</li> </ul> <h4 id="illustration-of-random-forests">Illustration of Random Forests</h4> <p><img src="https://raw.githubusercontent.com/lialittis/lialittis.github.io/master/assets/img/illustration_random_forests.png" alt=""></p> <p>Random forests allow to learn much more complex functions than basic decision trees. This fact is illustrated in this visualization. For the same training data set different numbers of decision trees are constructed (rCART is a variant of decision trees). We observe that with increasing numbers of trees the decision boundaries become increasingly more complex and smoother, and thus a better separation among different classes can be achieved.</p> <h3 id="q--a-2">Q &amp; A</h3> <p>The computational cost for constructing a RF with K as compared to constructing K decision trees on the same data</p> <p>A. is identical</p> <p>B. is on average larger</p> <p>C. is on average smaller</p> <p>Answer:[<font color:white="">C</font>]</p> <h3 id="characteristics-of-random-forests">Characteristics of Random Forests</h3> <p>Random forests are a very popular method for classification due to the many advantages they offer. They are considered as the method of choice in cases where the data is dense, which means that the number of features is relatively low (in the thousands). Sparse data would be, for example, vector space representation of documents with very large vocabularies. In such cases, before applying a method such as random forests, a dimensionality reduction would have to be applied. This could be accomplished in the case of documents by creating a word embedding.</p> <p>Strengths</p> <ul> <li>Ensembles can model extremely complex decision boundaries <strong>without overfitting</strong> </li> <li>Probably the most popular classifier for <strong>dense data</strong> (â‰¤ a few thousand features)</li> <li> <strong>Easy to implement</strong> (train a lot of trees)</li> <li><strong>Parallelizes easily, good match for MapReduce</strong></li> </ul> <p>More recently, in cases where large training sets are available or number of features is very large, deep neural networks exhibit better performance than random forests.</p> <p>Weaknesses</p> <ul> <li>Deep Neural Networks generally do better</li> <li>Needs many passes over the data â€“ at least the max depth of the trees</li> <li>Relatively easy to overfit â€“ hard to balance accuracy/fit tradeoff</li> </ul> <h2 id="references">references</h2> <p>Textbook</p> <ul> <li>Jiawei Han, Data Mining: concepts and techniques, Morgan Kaufman, 2000, ISBN 1-55860-489-8 References</li> <li>Leo Breiman (2001) â€œRandom Forestsâ€ Machine Learning, 45, 5-32.Â </li> <li>Shafer, John, Rakesh Agrawal, and Manish Mehta. â€œSPRINT: A scalable parallel classifier for data mining.â€Â Proc. 1996 Int. Conf. Very Large Data Bases. 1996.</li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Performance-Benefits-From-Underutilized-CPU/">How to Write A CORRECT LLVM Pass As A Plugin</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/How-to-Write-A-CORRECT-LLVM-Pass-As-A-Plugin/">How to Write A CORRECT LLVM Pass As A Plugin</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/What-is-Three-Address-Code/">What is Three Address Code (3AC) ?</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Lexical-Analysis,-Syntax-Analysis,-and-Semantic-Analysis-copy/">Lexical Analysis, Syntax Analysis, and Semantic Analysis</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Rust-Basics-1(Quick-Review)/">Rust Basics 1(Quick Review)</a> </li> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> Â© Copyright 2023 Tianchi YU. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js"></script> <script defer src="/assets/js/common.js"></script> <script defer src="/assets/js/copy_code.js" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>